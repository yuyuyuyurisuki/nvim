local M = {}

M.starts_with = function(str, start)
  return str:sub(1, #start) == start
end

M.ends_with = function(str, ending)
  return ending == "" or str:sub(- #ending) == ending
end

-- file exist?
M.exists = function(file)
  local ok, err, code = os.rename(file, file)
  if not ok then
    if code == 13 then
      -- Permission denied, but it exists
      return true
    end
  end
  return ok, err
end


M.SaveAndExit = function()
  -- wirte all buffer first
  vim.api.nvim_command(":wa")
  -- quit all buffer
  vim.api.nvim_command(":qa")
end


-- gtags
M.GtagsRefernce                                                               = function()
  local word = vim.api.nvim_call_function("expand", { "<cword>" })
  vim.api.nvim_command(":cs find c " .. word)
  vim.api.nvim_command(":copen")
end

M.GtagsText                                                                   = function()
  local word = vim.api.nvim_call_function("expand", { "<cword>" })
  vim.api.nvim_command(":cs find t " .. word)
  vim.api.nvim_command(":copen")
end

M.capabilities                                                                = require('cmp_nvim_lsp')
.default_capabilities(capabilities)

M.capabilities.textDocument.completion.completionItem.documentationFormat     = { 'markdown', 'plaintext' }
M.capabilities.textDocument.completion.completionItem.snippetSupport          = true
M.capabilities.textDocument.completion.completionItem.preselectSupport        = true
M.capabilities.textDocument.completion.completionItem.insertReplaceSupport    = true
M.capabilities.textDocument.completion.completionItem.labelDetailsSupport     = true
M.capabilities.textDocument.completion.completionItem.deprecatedSupport       = true
M.capabilities.textDocument.completion.completionItem.commitCharactersSupport = true
M.capabilities.textDocument.completion.completionItem.tagSupport              = { valueSet = { 1 } }
M.capabilities.textDocument.completion.completionItem.resolveSupport          = {
  properties = {
    'documentation',
    'detail',
    'additionalTextEdits',
  },
}

M.root_dir                                                                    = function()
  return vim.fn.getcwd()
end

-- Use an on_attach function to only map the following keys
-- after the language server attaches to the current buffer
M.on_attach                                                                   = function(client, bufnr)
  local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

  -- Highlighting references
  if client.server_capabilities.document_highlight then
    vim.api.nvim_exec([[
      augroup lsp_document_highlight
        autocmd! * <buffer>
        autocmd CursorHold <buffer> lua vim.lsp.buf.document_highlight()
        autocmd CursorMoved <buffer> lua vim.lsp.buf.clear_references()
      augroup END
    ]], false)
  end
  -- Enable completion triggered by <c-x><c-o>
  buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')
end


return M
